from typing import Any, Dict, Tuple
from threading import Thread
import pickle
import socket

import zmq

from lf_utils import instantiate, retry
from .machine_interfaces import MachineInterface


class LFServer(Thread):
    """Learning Factory Server

    Handles receiving data from machine interfaces and
    sending data to digital dashboard and virtual factory
    """
    machine_interfaces: Dict[str, MachineInterface]

    def __init__(
            self,
            data_port: int,
            machine_configs: Dict[str, Dict]
    ):
        """Initializes server thread, instantiates and starts machine interfaces,
        and sets up ZMQ sockets to machines and data publishing

        Parameters
        ----------
        data_port : int
            port to publish data to
        machine_configs : Dict[str, Dict]
            machine interface configs, used to instantiate machine interfaces
        """
        # create data socket
        self._context = zmq.Context()

        data_publish_address = f"tcp://*:{data_port}"
        self._data_publish_socket = self._context.socket(zmq.PUB)
        retry(
            self._data_publish_socket.bind,
            data_publish_address,
            handled_exceptions=zmq.error.ZMQError
        )

        # create receive socket and bind to receive address
        receive_port = self._get_free_port()
        self._receive_address = f"tcp://*:{receive_port}"
        self._receive_socket = self._context.socket(zmq.SUB)
        retry(
            self._receive_socket.bind,
            self._receive_address,
            handled_exceptions=zmq.error.ZMQError
        )

        # subscribe to all topics on receive socket
        self._receive_socket.setsockopt(zmq.SUBSCRIBE, b"")

        # set port in machine configs
        for machine_conf in machine_configs.values():
            machine_conf["port"] = receive_port

        # instantiate machine interfaces
        self.machine_interfaces = {
            machine_name: instantiate(machine_config)
            for machine_name, machine_config in machine_configs.items()
        }

        # start machine interfaces
        for machine_interface in self.machine_interfaces.values():
            machine_interface.start()

        # initialize thread
        Thread.__init__(self)
        self.stopped = False

    def run(self):
        """Runs main thread, receiving machine data from machine interfaces and
        sending that data to machine data subscribers
        """
        try:
            # loop until thread is stopped
            while not self.stopped:
                # receive data from machine interfaces (blocking)
                machine_name, machine_data = self._recv_data()

                # send data to digital dashboard, virtual factory
                self._send_data(machine_name, machine_data)

        # catch keyboard interrupts and gracefully exit thread
        except KeyboardInterrupt:
            pass

        self._exit_thread()

    def stop(self):
        """Asynchronously stops server thread"""
        self.stopped = True

    def _recv_data(self) -> Tuple[bytes, Dict[str, Any]]:
        """Receives and returns data from receive socket

        Returns
        -------
        Tuple[bytes, Dict[str, Any]]
            tuple of machine name and machine data dictionary
        """
        machine_name, machine_data_encoded = self._receive_socket.recv_multipart()

        return machine_name, pickle.loads(machine_data_encoded)

    def _send_data(self, machine_name: bytes, machine_data: Dict[str, Any]):
        """Sends machine data to data publishing socket

        Parameters
        ----------
        machine_name : bytes 
            name of machine (topic to publish on)
        machine_data : Dict[str, Any]
            machine data dictionary to send
        """
        # publish machine data to data socket
        self._data_publish_socket.send_multipart([
            machine_name,
            pickle.dumps(machine_data)
        ])

    def _exit_thread(self):
        """Stops machine interfaces and closes zmq sockets"""
        # stop machine interfaces
        for machine_interface in self.machine_interfaces.values():
            machine_interface.stop()

        # destroy zmq context
        self._context.destroy()

    @staticmethod
    def _get_free_port() -> int:
        """Gets random free port from OS

        Returns
        -------
        int
            port number, generated by OS
        """
        # generate free port
        free_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        free_socket.bind(("", 0))
        receive_port = free_socket.getsockname()[-1]

        # close socket
        free_socket.close()

        # return port number
        return receive_port

